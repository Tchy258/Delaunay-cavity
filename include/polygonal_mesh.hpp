// https://jerryyin.info/geometry-processing-algorithms/half-edge/
// https://doc.cgal.org/latest/Arrangement_on_surface_2/classCGAL_1_1Arrangement__2_1_1Halfedge.html
// https://threejs.org/docs/#examples/en/math/convexhull/HalfEdge.vertex


// half-edge triangulation
/*
Basic operations
    incident_face(e): return the face incident to e
    twin(e): return the twin halfedge of e
    next(e): return the next halfedge of e
    prev(e): return the previous halfedge of e
    origin(e): return the first vertex of halfedge e
    target(e): return the second vertex of halfedge e
Others
    CCW_edge_to_vertex(e): return the next CCW edge incident to v after e
    edge_of_vertex(v): return A edge incident to v
    is_border_face(e): return true if the incent face of e is a border face
    is_interior(e): return true if the incent face of e is an interior face
    is_border_vertex(e): return true if the vertex v is part of the boundary
    faces(): return number of faces
    halfEdges(): Return number of halfedges
    vertices(): Return number of vertices
    get_Triangles(): bitvector of triangles where true if the halfege generate a unique face, false if the face is generated by another halfedge
    get_PointX(int i): return the i-th x coordinate of the triangulation
    get_PointY(int i): return the i-th y coordinate of the triangulation

TODO:
    edge_iterator;
    face_iterator;
    vertex_iterator;
    copy constructor;
    constructor indepent of triangle
*/

#ifndef POLYGONAL_MESH_HPP
#define POLYGONAL_MESH_HPP

#include <chrono>
#include <array>
#include <vector>
#include <iostream>
#include <fstream>
#include <cmath>
#include <sstream>
#include <string>
#include <memory>
#include <unordered_map>
#include <map>
#include <chrono>
#include <concepts/mesh_data.hpp>
#include <mesh_io/mesh_reader.hpp>
#include <mesh_io/mesh_writer.hpp>
#include <mesh_refiners/mesh_refiner.hpp>
#include <misc/mesh_stat.hpp>
#include <misc/time_stat.hpp>
/**
 * Class that defines a polygonal mesh
 */
template <MeshData Mesh>
class PolygonalMesh {
private:
    double generationTime = 0.0;
    Mesh* meshData = nullptr;
    Mesh* refinedMesh = nullptr;
    std::unique_ptr<MeshReader<Mesh>> reader;
    std::unique_ptr<MeshWriter<Mesh>> writer;
    std::unique_ptr<MeshRefiner<Mesh>> refiner;
public:
    
    PolygonalMesh(std::unique_ptr<MeshReader<Mesh>> meshReader) : reader(std::move(meshReader)) {}
    PolygonalMesh(std::unique_ptr<MeshReader<Mesh>> meshReader, std::unique_ptr<MeshWriter<Mesh>> meshWriter) : reader(std::move(meshReader)), writer(std::move(meshWriter)) {}
    PolygonalMesh& setReader(std::unique_ptr<MeshReader<Mesh>> reader) {
        this->reader = std::move(reader);
        return *this;
    }
    PolygonalMesh& setWriter(std::unique_ptr<MeshWriter<Mesh>> writer) {
        this->writer = std::move(writer);
        return *this;
    }
    PolygonalMesh& setRefiner(std::unique_ptr<MeshRefiner<Mesh>> refiner) {
        this->refiner = std::move(refiner);
        return *this;
    }
    PolygonalMesh& readMeshFromFiles(const std::vector<std::filesystem::path>& filepaths) {
        auto start = std::chrono::high_resolution_clock::now();
        meshData =reader->readMesh(filepaths);
        auto end = std::chrono::high_resolution_clock::now();
        generationTime = std::chrono::duration<double, std::milli>(end - start).count();
        return *this;
    }
    PolygonalMesh& refineMesh() {
        if (refiner == nullptr) {
            throw std::runtime_error("Refiner must be set before attempting to refine mesh");
        }
        refinedMesh = refiner->refineMesh(meshData);
        return *this;
    }
    PolygonalMesh& writeOutputMesh(const std::vector<std::filesystem::path>& filepaths) {
        std::vector<typename Mesh::OutputIndex> output = {};
        if (refiner != nullptr) {
            output = refiner->getOutputSeeds();
        }
        writer->writeMesh(filepaths, *refinedMesh, output);
        return *this;
    }
    void writeStatsToJson(const std::filesystem::path& filepath) {
        //TODO: Logic for writing stats
    }
    const Mesh& getOriginalMeshData() const {
        return meshData;
    }
    const Mesh& getRefinedMeshData() const {
        return refinedMesh;
    }
    std::unordered_map<MeshStat,int> getRefinementStats() {
        if (refiner != nullptr) {
            std::unordered_map<MeshStat,int>& stats = refiner->getRefinementStats();
            return stats;
        } else {
            return std::unordered_map<MeshStat,int>{};
        }
    }
    std::unordered_map<TimeStat,double> getRefinementTimes() {
        if (refiner != nullptr) {
            std::unordered_map<TimeStat,double>& stats = refiner->getRefinementTimes();
            stats[T_TRIANGULATION_GENERATION] = generationTime;
            return stats;
        } else {
            return std::unordered_map<TimeStat,double>{};
        }
    }
    ~PolygonalMesh() {
        delete meshData;
        delete refinedMesh;
    }
};

#endif