// https://jerryyin.info/geometry-processing-algorithms/half-edge/
// https://doc.cgal.org/latest/Arrangement_on_surface_2/classCGAL_1_1Arrangement__2_1_1Halfedge.html
// https://threejs.org/docs/#examples/en/math/convexhull/HalfEdge.vertex


// half-edge triangulation
/*
Basic operations
    incident_face(e): return the face incident to e
    twin(e): return the twin halfedge of e
    next(e): return the next halfedge of e
    prev(e): return the previous halfedge of e
    origin(e): return the first vertex of halfedge e
    target(e): return the second vertex of halfedge e
Others
    CCW_edge_to_vertex(e): return the next CCW edge incident to v after e
    edge_of_vertex(v): return A edge incident to v
    is_border_face(e): return true if the incent face of e is a border face
    is_interior(e): return true if the incent face of e is an interior face
    is_border_vertex(e): return true if the vertex v is part of the boundary
    faces(): return number of faces
    halfEdges(): Return number of halfedges
    vertices(): Return number of vertices
    get_Triangles(): bitvector of triangles where true if the halfege generate a unique face, false if the face is generated by another halfedge
    get_PointX(int i): return the i-th x coordinate of the triangulation
    get_PointY(int i): return the i-th y coordinate of the triangulation

TODO:
    edge_iterator;
    face_iterator;
    vertex_iterator;
    copy constructor;
    constructor indepent of triangle
*/

#ifndef POLYGONAL_MESH_HPP
#define POLYGONAL_MESH_HPP

#include <chrono>
#include <array>
#include <vector>
#include <iostream>
#include <fstream>
#include <cmath>
#include <sstream>
#include <string>
#include <memory>
#include <unordered_map>
#include <map>
#include <chrono>
#include <concepts/mesh_data.hpp>
#include <mesh_io/mesh_reader.hpp>
#include <mesh_io/mesh_writer.hpp>
#include <mesh_generators/mesh_generator.hpp>
#include <misc/mesh_stat.hpp>
#include <misc/time_stat.hpp>
#include <misc/memory_stat.hpp>
/**
 * Class that defines a polygonal mesh
 */
template <MeshData Mesh>
class PolygonalMesh {
private:
    double generationTime = 0.0;
    Mesh* meshData = nullptr;
    Mesh* refinedMesh = nullptr;
    std::unique_ptr<MeshReader<Mesh>> reader;
    std::unique_ptr<MeshWriter<Mesh>> writer;
    std::unique_ptr<MeshGenerator<Mesh>> generator;
public:
    
    PolygonalMesh(std::unique_ptr<MeshReader<Mesh>> meshReader) : reader(std::move(meshReader)) {}
    PolygonalMesh(std::unique_ptr<MeshReader<Mesh>> meshReader, std::unique_ptr<MeshWriter<Mesh>> meshWriter) : reader(std::move(meshReader)), writer(std::move(meshWriter)) {}
    PolygonalMesh& setReader(std::unique_ptr<MeshReader<Mesh>> reader) {
        this->reader = std::move(reader);
        return *this;
    }
    PolygonalMesh& setWriter(std::unique_ptr<MeshWriter<Mesh>> writer) {
        this->writer = std::move(writer);
        return *this;
    }
    PolygonalMesh& setGenerator(std::unique_ptr<MeshGenerator<Mesh>> generator) {
        this->generator = std::move(generator);
        return *this;
    }
    PolygonalMesh& readMeshFromFiles(const std::vector<std::filesystem::path>& filepaths) {
        auto start = std::chrono::high_resolution_clock::now();
        meshData =reader->readMesh(filepaths);
        auto end = std::chrono::high_resolution_clock::now();
        generationTime = std::chrono::duration<double, std::milli>(end - start).count();
        return *this;
    }
    PolygonalMesh& generateMesh() {
        if (generator == nullptr) {
            throw std::runtime_error("Generator must be set before attempting to refine mesh");
        }
        refinedMesh = generator->generateMesh(meshData);
        return *this;
    }
    PolygonalMesh& writeMeshBeforePostProcess(const std::vector<std::filesystem::path>& filepaths) {
        std::vector<typename Mesh::OutputIndex> output = {};
        if (generator != nullptr) {
            output = generator->getOutputSeedsBeforePostProcess();
        }
        writer->writeMesh(filepaths, *(generator->getMeshBeforePostProcess()), output);
        return *this;
    }
    PolygonalMesh& writeOutputMesh(const std::vector<std::filesystem::path>& filepaths) {
        std::vector<typename Mesh::OutputIndex> output = {};
        if (generator != nullptr) {
            output = generator->getOutputSeeds();
        }
        writer->writeMesh(filepaths, *refinedMesh, output);
        return *this;
    }
    void writeStatsToJson(const std::filesystem::path& filepath) {
        std::unordered_map<MeshStat,int> meshStats = getGenerationStats();
        std::unordered_map<TimeStat,double> timeStats = getGenerationTimes();
        std::unordered_map<MemoryStat, unsigned long long> memoryStats = getGenerationMemory();
        std::ofstream json(filepath);

        auto writeBlock = [&]<typename StatType, typename StatValue>(std::unordered_map<StatType,StatValue> map, const unsigned int& totalValues, const char* const* names, bool appendFinalComma) {
            int maxKey = 0;
            for (const auto& [key, _] : map) {
                if (static_cast<int>(key) > static_cast<int>(maxKey)) {
                    maxKey = key;
                }
            }
            for (unsigned int i = 0; i < totalValues; ++i) {
                if (auto it = map.find(static_cast<StatType>(i)); it != map.end()) {
                    const auto& [key, value] = *it;
                    json << "  \"" << names[key] << "\": " << value;
                    if ((static_cast<int>(key) != maxKey) || (static_cast<int>(key) == maxKey && appendFinalComma)) {
                        json << ",";
                    }
                    json << "\n";
                }
            }
        };
        json << "{" << "\n";
        writeBlock(meshStats, meshStatAmount, MeshStatNames, true);
        writeBlock(timeStats, timeStatAmount, TimeStatNames, true);
        writeBlock(memoryStats, memoryStatAmount, MemoryStatNames, false);
        json << "}" << std::endl;
    }
    const Mesh& getOriginalMeshData() const {
        return meshData;
    }
    const Mesh& getRefinedMeshData() const {
        return refinedMesh;
    }
    std::unordered_map<MeshStat,int> getGenerationStats() const {
        if (generator != nullptr) {
            std::unordered_map<MeshStat,int> stats = generator->getGenerationStats();
            return stats;
        } else {
            return std::unordered_map<MeshStat,int>{};
        }
    }
    std::unordered_map<TimeStat,double> getGenerationTimes() const {
        if (generator != nullptr) {
            std::unordered_map<TimeStat,double> stats = generator->getGenerationTimes();
            stats[T_TRIANGULATION_GENERATION] = generationTime;
            return stats;
        } else {
            return std::unordered_map<TimeStat,double>{};
        }
    }

    std::unordered_map<MemoryStat,unsigned long long> getGenerationMemory() const {
        if (generator != nullptr) {
            std::unordered_map<MemoryStat,unsigned long long> stats = generator->getGenerationMemory();
            return stats;
        } else {
            return std::unordered_map<MemoryStat,unsigned long long>{};
        }
    }
    ~PolygonalMesh() {
        delete meshData;
        delete refinedMesh;
    }
};

#endif